import torch

class MultiPetriNet:
    def __init__(self, num_pns, length_pns=2):
        self.num_pns = num_pns
        self.length_pns = length_pns

        # Initialize tensors for markings, capacities, and weights
        self.markings = torch.zeros((num_pns, length_pns))
        self.capacities = torch.ones((num_pns, length_pns))
        self.weights = torch.ones((num_pns, length_pns))

        # Set weights according to the specified structure
        for i in range(length_pns - 1):
            weight_value = i * 2 + 1  # Calculate weight value based on index
            self.weights[:, i * 2] = weight_value  # Set transition-place weights
            self.weights[:, i * 2 + 1] = weight_value  # Set place-transition weights
        
        self.active_transitions = torch.zeros((self.num_pns, self.length_pns - 1), dtype=torch.bool)

    def set_initial_marking(self, pn_idx, marking):
        self.markings[pn_idx] = torch.tensor(marking)

    def set_capacity(self, pn_idx, place_idx, capacity):
        self.capacities[pn_idx, place_idx] = capacity

    def set_weight(self, pn_idx, weight_idx, weight):
        self.weights[pn_idx, weight_idx] = weight

    def fire_transition(self, pn_idx, transition_idx):
        # Calculate the corresponding place index for the given transition
        place_idx = transition_idx // 2

        # Check if the transition is enabled
        if self.is_enabled(pn_idx, place_idx):
            # Update markings
            self.markings[pn_idx, place_idx] -= self.weights[pn_idx, transition_idx]
            
            # Update active transitions after firing
            self.update_active_transitions(pn_idx)

    def is_enabled(self, pn_idx, place_idx):
        # Check if the input place has enough tokens to fire the transition
        return self.markings[pn_idx, place_idx] >= self.weights[pn_idx, place_idx]
    
    def update_active_transitions(self, pn_idx):
        # Iterate through each place in the Petri net
        for place_idx in range(self.length_pns - 1):
            # Check if the transition is enabled for the current place
            self.active_transitions[pn_idx, place_idx] = self.is_enabled(pn_idx, place_idx)

    def print_state(self):
        for i in range(self.num_pns):
            print(f"Petri Net {i} Markings: {self.markings[i]}")
            print(f"Petri Net {i} Capacities: {self.capacities[i]}")
            print(f"Petri Net {i} Weights: {self.weights[i]}")
            
# Example 1: Create a MultiPetriNet instance with length 2
mpn = MultiPetriNet(num_pns=1, length_pns=2)

# Set initial marking
mpn.set_initial_marking(0, [1, 0])

# # Set weight for the first transition-place pair
# mpn.set_weight(0, 0, 1)

# # Set weight for the first place-transition pair
# mpn.set_weight(0, 1, 2)

# # Fire the first transition
# mpn.fire_transition(0, 0)

# # Print the state
# mpn.print_state()
